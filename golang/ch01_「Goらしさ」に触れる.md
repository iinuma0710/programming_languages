# 第1章 「Go」らしさに触れる
ここでは，他の言語と比較しながら「Go らしい書き方」とはどういうものかを見ていきます．

## 1.1 変数やパッケージ，メソッドなどに名前をつけるには
Go の命名規則は [Effective Go](https://go.dev/doc/effective_go) に公式見解が示されています．

### 1.1.1 変数名
変数名には次のような命名規則があります．

- MixedCaps を使用する  
```max_length``` ではなく ```maxLength``` となる
- パッケージ外から参照する変数は先頭を大文字にする  
```maxLength``` をパッケージ外から参照するときは ```MaxLength``` となる
- 頭字語は全て大文字か小文字に統一する  
```URL```，```id``` など，他の単語と組み合わせるなら ```stackID``` のようになる
- ```Error``` 型としてふるまう型名には語尾に "Error" をつける
- エラーを表す変数は "Err" か "err" から始まる
- 変数名は短いものが好まれる  
特にスコープの限られるローカル変数の場合
- 宣言から離れた場所で用いられる変数には説明的な変数名を付ける  
ただし型名は静的に決定されるので変数名に含める必要はない

### 1.1.2 パッケージ名
パッケージ名は簡潔で，その内容を想像しやすい名前をつけるのが適切とされています
(```bytes```，```http``` など)．
それ以外の注意点として，次のようなものがあります．

- 汎用的な名前 (```util``` や ```common``` など) は避ける
- 2単語以上で構成される名前を使わない
- 全てのモジュールは先頭が小文字でも公開される
- パッケージ名と関数名に重複がないようにする

このうち，上の2つについてはフォルダを分けることで対処します．  
ただし，次のような例外もあります．

- ```internal``` パッケージだけはモジュール内でのみ参照される
- テスト用に ```パッケージ名_test``` というパッケージを作成することは認められる

### 1.1.3 インタフェース名
1つのメソッドのみを持つインタフェースでは，語尾に "er" のついた名前が用いられます．
ただし，```Driver``` インタフェースの ```Open``` メソッドのような例外もあります．  
一方で，インタフェースが複数のメソッドで構成される場合は，その目的を適切に説明できる名前を選ぶようにします．

### 1.1.4 レシーバ名
レシーバ名は，その型を反映した1文字，あるいは2文字を用いて命名します．
また，同じ型に対しては，プログラム内で一貫した名前をつけることが望ましいとされています．

## 1.2 定数の使い方
Go では異なる数値型動詞の演算を許していませんが，定数はより柔軟な使い方ができます．

### 1.2.1 型のない定数を定義する
Go では，変数や引数などに代入して利用する値のことを定数と呼んでおり，定数同士の演算はコンパイル時に静的に行われ，その値がバイナリで埋め込まれた状態の実行ファイルが生成されます．
代入や型の指定があるまでは型が決定されません．

```go
var a = 1 // イコールの右側の 1 が定数
var b = 1 + 100 // 定数の中で演算子を使った計算も可能
```

型を指定せず ```const``` キーワードを使うと，定数に名前をつけられます．

```go
const (
    a = 1 // イコールの右側の 1 が定数
    b = 1 + 2 // 演算もできる
    c = 9223372036854775807 + 1 // uint64 を超える数値も定義可能
    d = "hello world" // 整数以外に浮動小数点数や文字列やブール型も扱える
    e = iota + 10 // const 宣言でのみ iota も使える
)
```

定数を ```var``` に割り当てたり，関数の引数として渡すことも可能で，その時に型が指定されていなければそれぞれの定数のデフォルトとなる型が設定されます．
一方，型名を指定したり，型の指定された関数の引数に渡すと，そのタイミングで変数の値の範囲がチェックされます．  
定数は，簡単な演算や ```iota``` を用いたインクリメントは可能ですが，それ以外の複雑な演算は不可能です．

### 1.2.2 型付き const 変数を定義する
定数名の横に型名を指定すると，値の書き換えのできない型付きの定数になります．

```go
type ErrorCode int

const (
    f    int       = 10 
    code ErrorCode = 10
)
```

基本的な制約は型のない定数と同様ですが，次のような点で異なります．

- 関数の返り値を定数にすることはできない
- 配列やスライス，マップを定数とすることはできない

```go
const (
    g int32 = 4294967295 + 1 // これは型の範囲を超えるためエラーになる
    h []int = []int{1, 2, 3} // 配列やスライスはエラー
    i map[string]int = map[string]int{ // マップもエラー
        "Tokyo": 10,
        "Kanagawa": 11,
        "Chiba": 12, 
    }
    j = function() // 関数の返り値もエラー
)
```

### 1.2.3 他言語との違い
Go では ```const``` をコンパイル時に決定される不変の値として利用しています．
一方，C++ では構造体やクラスの属性値の変更を許さないという意味になります．
また，JavaScript や TypeScript では変数の再代入を許さないという意味になり，値の変更の禁止は ```readonly``` という別の修飾子を付与することで実現できます．
このような微妙な差異をしっかりと理解しておく必要があります．

### 1.2.4 定数で error 型のインスタンスを提供する
エラー判定処理で，定数として ```error``` 型のインスタンスを作成しておいて，```==``` 演算子でエラーの種別を判断できれば便利ですが，構造体などは定数として設定できませんでした．
そのため，次のコードはコンパイルエラーとなってしまいます．

```go
const ( 
    // New() 関数の返り値は実行時まで決まらないので const にできない
    ErrDatabase = errors.New("Database Error") 
)
```

そこで，プリミティブ型の定義型を作成し，メソッドを定義して ```error``` インタフェースを満たし，そのインスタンスを ```const``` に設定してやります．

```go
type errDatabase int

func (e errDatabase) Error() string {
    return "Database Error"
}

const (
    ErrDatabase errDatabase = 0
)

// エラーハンドリングの例
err := OpenDB("postgres://localhost:5432")
if err == ErrDatabase{
    log.Fatal("DB 接続エラー")
}
```

しかし，大抵の場合，エラーインスタンスは ```var``` で定義されており，上書きしようと思えば簡単にできてしまいます．
ただ，そこは性善説でプログラマを信じるというのが Go のスタンスです．

## 1.3 iota を用いて列挙型を実現する
エラーコードやマジックナンバーをコードの中にベタ打ちしてしまうと，プログラムの変更が生じた場合などに修正漏れによるバグの原因になり得ます．
これを防ぐために，多くのプログラミング言語では列挙型を用いて決まった値の集合を定義してやります．
Go では列挙型は提供されていませんが，いくつかの要素を組み合わせて列挙型に近い機能を実現できます．

- 種別を表す型を ```type``` キーワードで作成
- 定数のリストを ```const``` で作成
- 定数に割り当てる値として ```iota``` を利用

### 1.3.1 それぞれユニークな値を持つ定数を定義
最初にベースとなる型を定義しておきます．
一般的に ```int``` がよく用いられます．

```go
type CarType int
```

```iota``` は参照されるたびにインクリメントされる値です．
また，```const``` 宣言の中で変数名のみを記述した行では，直前で使用した値がそのまま指定されます．
すなわち，次のコードでは各行で ```iota``` が参照されるため，それぞれの定数にユニークな値が割り当てられます．

```go
const (
    Sedan CarType = iota + 1
    Hatchback
    MPV
    SUV
    Crossover
    Coupe
    Convertible
)
```

```iota``` の初期値は0なので，初期化されていないゼロ値の状態に名前をつけたい場合以外は，```iota+1``` で値を設定します．
利用する時には次のように利用します．

```go
var t CarType
t = SUV
```

### 1.3.2 iota の挙動
```iota``` は，より正確には参照されるたびではなく，最初に参照されてから空行を除いて行が変わるごとにインクリメントされます．
また，```const``` ブロックが複数ある場合には，ブロックごとに値が0にリセットされます．

```go
const (
    a = iota // 0
    b // 1
    c // 2
    _ // 3だが使われない // 空行は無視
    d // 4
    e = iota // 5
)

const (
    f = iota // 再び0
    g // 1
    h // 2
)
```

### 1.3.3 組み合わせてフラグとして利用する定数の実現
排他的な定数を定義するだけでなく，ビットシフトによって組み合わせを表現するフラグも ```iota``` を用いて実現できます．

```go
type CarOption uint64

const (
    GPS CarOption = 1 << iota
    AWD
    SunRoof
    HeatedSeat
    DriverAssist
)
```

この例では，1，2，4，8と2の冪乗が順番に格納されます．
これらの定数の論理和や論理積を計算してフラグとして利用します．

```go
var o CarOption
o = SunRoof | HeatedSeat

if o&SunRoof != 0 {
    fmt.Println(" サンルーフ付き ") }
```

### 1.3.4 iota を使うべきではない時
```const``` の新たな要素を追加すると，末尾に追加した場合を除いて他の要素についても，その値が変わります．
例えば，Go でサーバを立てて，クライアントからのリクエストに定数の値を使ってレスポンスを返すとき，新たな要素が定数の宣言に追加されると，サーバ内部紙の処理は変更に追従できても，クライアントへのレスポンスの意味が変わってしまいます．
このように，1つのプロセスにとどまらず，複数，あるいは外部のプロセスにまたがって利用される定数は，```iota``` を使わず1つずつ定数を割り当てるのが無難です．

### 1.3.5 文字列として出力可能にする
```int``` ベースの列挙型は，ログとして出力した場合などに整数値がそのまま出力されるため，ログ出力を読むのが大変です．
そこで，Go の ```stringer``` コマンドで整数値を文字列に変換してやります．

```bash
$ go install golang.org/x/tools/cmd/stringer@latest
```

次に，定数を定義しているファイルに，次のコメント行を追記します．

```go
//go:generate stringer -type=CarOption
//go:generate stringer -type=CarType
```

そして，```go generate``` を実行すると，```cartype_string.go``` と ```caroption_string``` というファイルが作成されます．
これで，整数で定義した定数が文字列に変換されて出力されます．

```go
c := Convertible
fmt.Printf("握力王の愛車は%sです\n", c)
// 握力王の愛車はConvertibleです
```

```stringer``` 以外にも，文字列から定数への変換や定数の列挙などを実現する ```enumer``` というライブラリもあります．

```bash
$ go install github.com/alvaroloes/enumer@latest

//go:generate enumer -type=CarOption -json
//go:generate enumer -type=CarType -json
```

このコマンドでは，定数一覧を返す ```CarOptionValues()``` や，文字列から定数にする```CarOptionString(s string)``` 関数が生成されます．
また，ここでは ```-json``` オプションを付けたので，JSON変換で用いられる ```MarshalJSON()``` と ```UnmarshalJSON()``` メソッドも生成されます．
JSON ファイルを生成するときには文字列にして，JSON をパースするときに定数にすることで，外部とやりとりが発生する場合にも ```iota``` を使っても問題なくなります．

## 1．4 Go のエラーを扱う
### 1.4.1 Go のエラーは値
Go のエラーは ```error``` 型のインタフェースを満たす単なる値です．
このインタフェースに格納される ```nil``` 値はエラーがないことを表します．
また，Go には例外処理を扱う組み込み構文は存在しません．

