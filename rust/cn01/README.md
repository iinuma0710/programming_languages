# 第1章 システムプログラマには素晴らしいものがある

```
ある文脈，例えば Rust がターゲットとしている文脈では，競合相手と10倍や2倍の速さを実現することは，運命を左右することになります．ハードウェア市場と同じように，市場におけるシステムの運命を決定するのです．
(by Graydon Hoare)

今や全てのコンピュータは並列動作しています．
並列プログラミングこそがプログラミングです．
(by Michael McCool et al., Structured Parallel Programming)

国家レベルの攻撃者の監視に利用している TrueType パーサの欠陥．すべてのソフトウェアは機密情報です．
(by Andy Wingo)
```

この本の冒頭に，上の3つの名言を選んだのには理由があります．
ただ，その前に謎解きから始めましょう．
次のような C プログラムは何をしているでしょうか？

```c
int main(int argc, char **argv) {
    unsigned long a[1];
    a[3] = 0x7ffff7b36cebUL;
    return 0;
}
```

実行するマシンによって結果は異なりますが，次のようなエラーを吐いてこのコードはクラッシュします．

```bash
undef: Error: .netrc file is readable by others.
undef: Remove password or make file unreadable by others.
```

何が起きているのでしょうか？  
このプログラムには欠陥があります．
```a``` は要素数が1なので，```a[3]``` を使うと，C 言語の標準に則れば「未定義の動作」となります．

```
この国際規格が要求していない、移植性のない、誤ったプログラム構造または誤ったデータを使用した場合の動作
```

「未定義の動作」は単に予測できない結果をもたらすだけではありません．
規格では明示的にプログラムのすべての動作を許しています．
先ほどの例では，ある配列の4番目の要素にある値を格納したことで，たまたま関数のコールスタックが破壊されてしまい，メイン関数に戻ってくるときに，本来のように何ら問題なくプログラムが終了する代わりに，ユーザのホームディレクトリのファイルからパスワードを検索する C ライブラリのコードに飛ばされてしまいました．
これは良くないですね．

C や C++ には未定義の動作を回避するために何百ものルールが定められています．
そのほとんどは常識的なルールです．
アクセスすべきでないメモリにはアクセスしない，オーバーフローを招くような算術演算をしない，ゼロ除算はしないなどです．
しかし，コンパイラはこれらのルールを強制はしません．
もし，明らかな違反があってもそれを検出してくれないのです．
実際，先ほどのプログラムはエラーや警告もなくコンパイルが通ります．
つまり，未定義の動作を回避する責任はプログラマにあるのです．

経験的に言って，我々プログラマにはこの点においてよい実績があるとは言えません．
Peng Li はユタ大学の学生だった時，C や C++ のコンパイラをプログラムが特定の未定義の動作を実行したかどうかをレポートするように修正しました．
これによって，コードに高い基準を設けているような，よく知られたプロジェクトも含めて，ほぼすべてのプログラムが未定義の動作をしていることが分かりました．
結局のところ，C や C++ で未定義の動作を回避できると思うことは，ルールを知ってさえいればチェスに勝てると思っているようなものなのです．

たまにおかしなメッセージやクラッシュが起きるのは品質的な問題かもしれません．
しかし，インターネットの初期に，先程述べた技術の1つを使ってコンピュータからほかのコンピュータへと次々に伝播していった Morris Worm が1988年に登場して以来，意図しない未定義の動作はセキュリティ欠陥の大きな原因になってきました．

C や C++ によってプログラマは難しい立場に立たされます．
これらの言語はシステムプログラミングの業界標準となっていますが，プログラマにすべてを委ねることによって，クラッシュやセキュリティの問題を次々に引き起こしているとも言えるのです．
先ほどの謎に答えることは，より大きな問題を提起することになります．
それは，我々はもっとうまくできないかということです．

## Rust はあなたの責任を肩代わりしてくれる
その問いに対する私たちの答えが，冒頭で引用した文章というわけです．
3つ目の引用は，2010年に産業機械に潜り込んだところを発見されたコンピュータワーム Stuxnet が，多くの技術の中からワープロ文書に埋め込まれた TrueType フォントの解析用コードの中の未定義の動作を用いて，コンピュータの制御を奪った事例の報告書から引いています．
このコードの作成者は，このような形でコードを利用されるとは思ってもみなかったでしょう．
このことは，セキュリティについて考慮する必要があるのは，OS やサーバに限った話ではないことを示しています．
つまり，信頼されていないソースからデータを扱うソフトウェアは，すべて悪用される可能性があるということです．

Rust はシンプルなお約束をします．
それは「コンパイラのチェックを通ったプログラムは，未定義の動作を含まない」ということです．
Dangling ポインタや二重解放，null ポインタからの値の取得は，すべてコンパイル時に捕捉されます．
配列への参照はコンパイル時と実行時に複数回安全を確認するので，バッファオーバーランは起こりません．
C 言語のプログラムと同じエラーがある場合には，エラーメッセージを出して安全に終了します．

さらに，Rust は安全性と使う喜びの両方を目標としています．
プログラムの動作を強く保証するために，C や C++ よりも厳しい制約を課しており，使いこなすには練習と経験が必要です．
しかし，言語全体としては柔軟で表現力に富んでいます．
これこそが，Rustで書かれたコードの幅広さと，適用されるアプリケーションの範囲の証明なのです．

経験的に，より多くの間違いを見つけてくれることで言語を信頼できるようになり，結果としてより野心的なプロジェクトに挑戦しようという気になります．
メモリ管理やポインタの妥当性の問題が処理されているとわかっていれば，巨大で複雑なプログラム修正のリスクを下げることができます．
また，バグの潜在的な結果としてプログラムの無関係な部分が破壊されることがなければ，デバッグはより簡単になります．

もちろん，Rust の検出できないバグもまだまだたくさんあります．
しかし，実際には未定義の動作を排除することで，開発の性質は大きく改善されます．

## 並列プログラミングを手懐ける
C や C++ で正しく使うのは難しいことで悪名高いのが並行処理です．
大抵，シングレスレッド向けに書いたコードが必要な性能を達成できないときにしか平行処理は使われません．
しかし，冒頭の2つ目の引用文では，並列処理は現代のマシンにとって非常に重要で，最後の手段として扱うべきではないと主張しています．

実の所，Rust でのメモリ安全性を保証するのと同じ制約によって，Rust プログラムがデータ競合を生じないことが保証されています．
データは変更されない限りにおいて，スレッド間で自由に共有できます．
変更したデータは同期プリミティブを使雨ことによってのみアクセスが可能です．
mutex や条件変数 (condition variable)，チャネル (channel) やアトミック (atomic) など，従来の並列処理ツールは全て使えます．
Rust は単にそれが正しく使われているかチェックするだけです．

これによって，Rust は最近のマルチコアマシンの力を引き出す素晴らしいプログラミング言語となったのです．
Rust のエコシステムによって，通常のプリミティブな並列処理にとどまらず，複雑な負荷をプロセッサプールに均等に分散したり，```Read-Copy-Update``` のようにロックフリーな同期メカニズムを利用したりといったライブラリが実現されています．

## そしてやはり　Rust は速い
最後に，これは最初の引用文に該当します．
Rust は Bjarne Stroustrup 氏が論文「抽象化と C++ マシンモデル」(Abstraction and C++ Machine Model) で述べた野心を共有しています．

```
一般的に，C++ の実装は「使わなないものにコストは払わない」というゼロオーバヘッドの原則に則っています．
もっと言えば「使うものにこれ以上良いコードは作れないだろう」
```

システムプログラミングでは，マシンの制限に悩まされることがよくあります．
ビデオゲームでは，プレイヤが最高の体験をできるように全ての機器が製作されています．
Webブラウザは，コンテンツ作成者ができることをブラウザの効率の上限に設定しています．
マシンの制限の中で，可能な限り多くのメモリとプロセッサをコンテンツ自体に残しておく必要があります．
同じ原則が OS にも当てはまります．
つまり，カーネルはマシンリソースを自身で使い切るのではなく，ユーザプログラムが利用できるようにしておかなければならないのです．

しかし，Rust が「速い」といった時に，実際には何を意味するのでしょうか？
遅いコードはどんな汎用言語でも記述できます．
より正確には，マシンの能力を最大限に活かせるプログラムの設計に投資する用意があるのならば，Rust はそれをサポートするということです．
Rust は効率的なデフォルト設定で設計されており，メモリの使用方法やプロセッサの利用方法などを制御することができます．

## Rust はコラボレーションを容易にする
実はこの章のタイトル「システムプログラマには素晴らしいものがある (Systems programmers can have nice things.)」には，4つ目の引用が隠されていました．
これは，Rust のコード共有や再利用を表しています．

Rust のパッケージマネージャでビルドツールである Cargo によって，Rust の[パブリックパッケージリポジトリ](https://crates.io)にある誰かの作ったライブラリを簡単に使えるようになります．
ファイルにライブラリの名前とバージョンを加えるだけで，ライブラリのダウンロードや他に必要なライブラリの取得，及びリンクなどの作業を全て Cargo がやってくれます．
Cargo は正しいバージョン管理と再現性のあるビルドに重点を置いた Rust 版の NPM や RubyGems と考えられます．
Rust ではそのまま使えるシリアル化から HTTP クライアントやサーバ，モダンなグラフィック API に至るまで，人気のライブラリが提供されています．

さらに進んでいくと，言語自体がコラボレーションを意識した設計になっていることがわかるでしょう．
Rust の traits と generics は，柔軟なインターフェイスを持つライブラリを作成することで，様々な文脈に対応することができます．
また，Rust の標準ライブラリでは基本的な型のコアセットを提供しており，一般的なケースで共通の習慣を確立することで，異なるライブラリの併用が容易になっています．

次の章では，ここまでで述べてきた内容を，簡単な Rust のコードを元に見ていきます．