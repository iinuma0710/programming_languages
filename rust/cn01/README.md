# 第1章 システムプログラマには素晴らしいものがある

```
ある文脈，例えば Rust がターゲットとしている文脈では，競合相手と10倍や2倍の速さを実現することは，運命を左右することになります．ハードウェア市場と同じように，市場におけるシステムの運命を決定するのです．
(by Graydon Hoare)

今や全てのコンピュータは並列動作しています．
並列プログラミングこそがプログラミングです．
(by Michael McCool et al., Structured Parallel Programming)

国家レベルの攻撃者の監視に利用している TrueType パーサの欠陥．すべてのソフトウェアは機密情報です．
(by Andy Wingo)
```

この本の冒頭に，上の3つの名言を選んだのには理由があります．
ただ，その前に謎解きから始めましょう．
次のような C プログラムは何をしているでしょうか？

```c
int main(int argc, char **argv) {
    unsigned long a[1];
    a[3] = 0x7ffff7b36cebUL;
    return 0;
}
```

実行するマシンによって結果は異なりますが，次のようなエラーを吐いてこのコードはクラッシュします．

```bash
undef: Error: .netrc file is readable by others.
undef: Remove password or make file unreadable by others.
```

何が起きているのでしょうか？  
このプログラムには欠陥があります．
```a``` は要素数が1なので，```a[3]``` を使うと，C 言語の標準に則れば「未定義の動作」となります．

```
この国際規格が要求していない、移植性のない、誤ったプログラム構造または誤ったデータを使用した場合の動作
```

「未定義の動作」は単に予測できない結果をもたらすだけではありません．
規格では明示的にプログラムのすべての動作を許しています．
先ほどの例では，ある配列の4番目の要素にある値を格納したことで，たまたま関数のコールスタックが破壊されてしまい，メイン関数に戻ってくるときに，本来のように何ら問題なくプログラムが終了する代わりに，ユーザのホームディレクトリのファイルからパスワードを検索する C ライブラリのコードに飛ばされてしまいました．
これは良くないですね．

C や C++ には未定義の動作を回避するために何百ものルールが定められています．
そのほとんどは常識的なルールです．
アクセスすべきでないメモリにはアクセスしない，オーバーフローを招くような算術演算をしない，ゼロ除算はしないなどです．
しかし，コンパイラはこれらのルールを強制はしません．
もし，明らかな違反があってもそれを検出してくれないのです．
実際，先ほどのプログラムはエラーや警告もなくコンパイルが通ります．
つまり，未定義の動作を回避する責任はプログラマにあるのです．

経験的に言って，我々プログラマにはこの点においてよい実績があるとは言えません．
Peng Li はユタ大学の学生だった時，C や C++ のコンパイラをプログラムが特定の未定義の動作を実行したかどうかをレポートするように修正しました．
これによって，コードに高い基準を設けているような，よく知られたプロジェクトも含めて，ほぼすべてのプログラムが未定義の動作をしていることが分かりました．
結局のところ，C や C++ で未定義の動作を回避できると思うことは，ルールを知ってさえいればチェスに勝てると思っているようなものなのです．

たまにおかしなメッセージやクラッシュが起きるのは品質的な問題かもしれません．
しかし，インターネットの初期に，先程述べた技術の1つを使ってコンピュータからほかのコンピュータへと次々に伝播していった Morris Worm が1988年に登場して以来，意図しない未定義の動作はセキュリティ欠陥の大きな原因になってきました．

C や C++ によってプログラマは難しい立場に立たされます．
これらの言語はシステムプログラミングの業界標準となっていますが，プログラマにすべてを委ねることによって，クラッシュやセキュリティの問題を次々に引き起こしているとも言えるのです．
先ほどの謎に答えることは，より大きな問題を提起することになります．
それは，我々はもっとうまくできないかということです．

## Rust はあなたの責任を肩代わりしてくれる
その問いに対する私たちの答えが，冒頭で引用した文章というわけです．
3つ目の引用は，2010年に産業機械に潜り込んだところを発見されたコンピュータワーム Stuxnet が，多くの技術の中からワープロ文書に埋め込まれた TrueType フォントの解析用コードの中の未定義の動作を用いて，コンピュータの制御を奪った事例の報告書から引いています．
このコードの作成者は，このような形でコードを利用されるとは思ってもみなかったでしょう．
このことは，セキュリティについて考慮する必要があるのは，OS やサーバに限った話ではないことを示しています．
つまり，信頼されていないソースからデータを扱うソフトウェアは，すべて悪用される可能性があるということです．

Rust はシンプルなお約束をします．
それは「コンパイラのチェックを通ったプログラムは，未定義の動作を含まない」ということです．
Dangling ポインタや二重解放，null ポインタからの値の取得は，すべてコンパイル時に捕捉されます．
配列への参照はコンパイル時と実行時に複数回安全を確認するので，バッファオーバーランは起こりません．
C 言語のプログラムと同じエラーがある場合には，エラーメッセージを出して安全に終了します．

