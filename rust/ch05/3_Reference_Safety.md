# 5-3. 参照の安全性
ここまで見てきた通り，参照は通常の C/C++ ポインタと極めてよく似ています．
しかし，ポインタは安全ではありません．
Rust はどのように参照を制御しているのでしょうか？
挙動の規則を理解するためには，それを破ってみるのが一番良い方法かもしれません．

基礎的な考え方への橋渡しとして，ある一つの関数の本体でどのように参照が適切に使われるかという，最もシンプルな場合を例に見てみましょう．
その後，関数間で参照を渡したり，構造体にデータを格納する場合を見ていきます．
これには，当該の関数やデータ型に「ライフタイムパラメータ」(lifetime parameter) を与えることが必要ですが，これについても説明します．
最後に，一般的な使用パターンを簡略化するために Rust が提供するショートカットをいくつか紹介します．
また，Rustがどのように壊れたコードを指摘し，解決策を提案するかを紹介します．

## ローカル変数を借用する
これは極めて明らかなケースです．
ローカル変数への参照は参照できませんし，変数のスコープを超えて持ち出すこともできません．

```rust
{
    let r;
    {
        let x = 1;
        r = &x;
    }
    assert_eq!(*r, 1);  // bad: reads memory `x` used to occupy
}
```

このコードはコンパイルで弾かれてエラーが出ます．

```bash
error: `x` does not live long enough
   |
7  |         r = &x;
   |             ^^ borrowed value does not live long enough 
8  |     }
   |     - `x` dropped here while still borrowed
9  |     assert_eq!(*r, 1);  // bad: reads memory `x` used to occupy
10 | }
```

メッセージでは，参照が外側のブロックの最後まで生き残る一方で，```x``` の寿命が内側のブロック野中に限られると言っています．
そのため，ダングリング・ポインタが作られてしまいますが，これは禁止されています．

人が見る分にはこのプログラムが壊れていることは一目瞭然ですが，Rust がどうやって判断しているのかは見てみる価値があるでしょう．
このような簡単な例でも，より複雑なコードをチェックするのに使われる論理的なツールを知ることができます．



## 関数の引数として参照を受け取る


## 関数に参照を渡す


## 参照を返す


## 参照を含む構造体


## 明確なライフタイムパラメータ


## ライフタイムパラメータの省略
