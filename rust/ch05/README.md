# 第5章 参照
```
ライブラリは新しい不可能を与えることはできない
Libraries cannot provide new inabilities.

(by Mark Miller)
```

シンプルなヒープ領域のポインタである ```Box<T>```， ```String``` や ```Vec``` の値に埋め込まれたポインタなど，これまで見てきたポインタ型は全て，ポインタを所有しており，所有者がドロップされると参照先もそれに従ってドロップされていました．
Rust には所有しないポインタ型も存在し，「参照」(reference) と呼ばれます．
参照は参照先の寿命には，何の影響もありません．

実際には，真逆の関係にあります．
つまり，参照は参照先の寿命を超えて生き残ることはできません．
参照が指し示す値より長く生存できないことは，コードの中で明確にしておかなければなりません．
これを強調するため，Rust では，ある値への参照を作成することを，値を「借用する」(borrow) と呼びます．
借りたものは，いずれ所有者に返さなければなりません．

「明確にしておかなければなりません」というフレーズが気になった人は，素晴らしい感覚を持っています．
参照自体，内部的にはただのアドレスで，なんら特別なものではありません．
しかし，その安全性を保つためのルールは Rust にとって斬新なもので，研究言語以外では見られないようなものになっています．
そして，このルールは Rust で最も習得に苦労する部分ではありますが，このルールによって古典的で必ず毎日のように起きるバグを驚くほど幅広く防ぐことが可能で，マルチスレッドプログラミングにも応用できるものとなっています．
これも，Rust の「過激な賭け」なのです．

本章では，Rust の参照の仕組みや，参照，関数，ユーザ定義型が安全に使用されるためのライフタイム情報の組み込み方法，これらの取り組みによって，コンパイル時に実行性能の低下を生じることなく防ぐことのできる一般的なバグのカテゴリについて見ていきます．

## 目次
- 5-1. [値への参照](./1_References_to_Values.md)
- 5-2. [参照を扱う](./2_Working_with_References.md)
- 5-3. [参照の安全性](./3_Reference_Safety.md)
- 5-4. [共有 vs ミューテーション](./4_Saring_Versus_Mutaion.md)
- 5-5. [オブジェクトの海に立ち向かう](./5_Taking_Arms_Against_a_Sea_of_Objects.md)