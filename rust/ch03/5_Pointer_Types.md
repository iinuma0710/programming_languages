# 3-5. ポインタ型
Rust にはメモリのアドレスを表す型がいくつかあります．
これは，Rust とガベッジ・コレクション (garbage collection) 機能のあるプログラミング言語との大きな違いです．
例えば，Java で ```Vector2D upperLeft;``` というフィールドを含む ```class Rectangle``` がある時，```upperLeft``` はそれとは別に作られた ```Vector2D``` のオブジェクトへの参照となります．
Java ではオブジェクト内に物理的に他のオブジェクトが含まれることはありません．

一方，Rust はメモリ確保が最小になるように設計されており，デフォルトで値はネストしています．
```((0, 0), (1440, 900))``` という値は4つの隣接する整数としてストアされます．
この値をローカル変数にストアした場合には，4つ分の整数の幅を持つローカル変数が得られます．
ヒープ領域には何も確保されません．

これによってメモリの使用効率は向上しますが，結果的に，Rust のプログラムで他の値を指し示す値が必要な場合には，明示的にポインタ型を使う必要があります．
ただ，Rust で使われるポインタ型には未定義の動作 (undefined behavior) は含まれないので，C++ に比べるとずっと簡単に正しく使えるようになります．

## 参照 (References)
```&String``` は "ref string" と読み，```String``` 型の値への参照です．
また，```&i32``` は ```i32``` 型への参照です．

実行時には，```i32``` への参照は，```i32``` のアドレスを保持する単一の機械語で，スタック領域かヒープ領域上にあります．
```&x``` は ```x``` への参照を表し，Rust の用語では「```x``` への参照を借りる」 (barrows a reference to ```x```) と言います．
また，参照 ```r``` が与えられた時，```*r``` は ```r``` の指し示す値を表します．
これらは，C/C++ の ```&``` や ```*``` 演算子ととてもよく似ています．
C のポインタと同様，スコープから外れた場合でも，自動的にリソースが解放されることもありません．

しかし，C のポインタとは異なり，Rust のポインタは Null 値を取りません．
これは，Rust に Null ポインタを生成する方法がないからです．
また，C とは異なり Rust では所有権 (qwnership) やライフタイム (lifetimes) を追跡しているので，ダングリング・ポインタ (dangling pointer) や二重解放 (double free)，無効なポインタはコンパイル時に弾かれます．

Rust の参照には2種類あります．

- ```&T```  
  イミュータブルな共有の参照．与えられた値に対しては一度に多くの共有された参照を持つことができるが，全て読み込み専用で指し示す先の値を書き換えることはできない．C の ```const T*``` と似た動作をする．
- ```&mut T```  
  ミュータブルで排他的なポインタ．C の ```T*``` と同じく，指し示す先の値を読むだけでなく修正することもできる．ただし，参照が存在する限りその値に対する他のいかなる種類の参照も持つことはできない．実際，その値にアクセスするには，変更可能な参照を通じてアクセスするしかない．

Rust はこの共有参照とミュータブルな参照という二項対立を利用して，「単一の書き手または複数の読み手」(single writer or multiple readers) というルールを強制しています．
これは，値の読み取りと書き込みが可能か，または任意の数の読み手で共有できるが，両方を同時に行うことはできないということです．
この分離はコンパイル時のチェックにより強制され，Rustの安全性保証の中心となっています．
Rustの安全な参照使用ルールについては第5章で扱います．

## ボックス (Boxes)
ヒープ領域に値を確保するには ```Box::new``` を使うと簡単に実現できます．

```rust
let t = (12, "eggs");
let b = Box::new(t);  // allocate a tuple in the heap
```

```t``` は ```(i32, &str)``` という型なので，```b``` は ```Box<(i32, &str)>``` 型になります．
```Box::new``` の呼び出しによって，ヒープ領域上にタプルを格納するのに十分なメモリが確保されます．
```b``` がスコープから外れると，```b``` が移動されていない限り直ちにメモリが解放されます．
この移動は Rust においてヒープ領域のメモリを確保するのに重要なので，第4章で詳しく説明します．

## 生ポインタ (Raw Pointer)
Rust には，生ポインタと呼ばれる ```*mut T``` 型と ```*const T``` 型があります．
生ポインタは C++ のポインタに非常によく似ています．
Rust は生ポインタの指し示すものをトラッキングしないので，Null ポインタとなったり，解放したメモリや型の異なる値を指し示したりと，生ポインタは安全ではありません．

ただし，生のポインタを参照できるのは ```unsafe``` ブロックの中だけです．
```unsafe``` ブロックは，Rust の先進的な言語機能のためのオプトイン機構であり，その安全性は開発者次第です．
```unsafe``` ブロックがない（または正しく記述されている）コードでも，Rust の安全性保証は維持されます．
詳細については第22章で扱います．
