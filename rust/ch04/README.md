# 第4章 所有権 (ownership) と移動 (move)
メモリの管理をする上で，プログラミング言語に求める特性は2つあります．

- 選んだタイミングで速やかにメモリを解放できること．これによって，プログラムのメモリ消費をコントロールできる．
- 解放済みのオブジェクトを指すポインタを使わないこと．未定義の動作となってクラッシュやセキュリティホールを引き起こす．

しかし，これらは背反するように見えます．
ポインタが存在する状態で値を解放すると，そのポインタがダングリング・ポインタになってしまうからです．
ほとんど全ての主要なプログラミング言語は，この2つのうちいずれかを諦めるかによって，2つの陣営に分かれています．

- 「安全第一」の陣営は，メモリの管理にガベージコレクションを使い，到達可能な全てのポインタについて自動的にオブジェクトを解放します．これはぶら下がるポインタがなくなるまでオブジェクトを保持し続けることで，ダングリング・ポインタを排除しています．Python や JavaScript，Ruby，Java，C#，Haskell など，ほとんどすべてのモダンな言語がこちらに属します．しかし，ガベージコレクションに依存するということは，オブジェクトを解放するタイミングの制御をコレクタに委ねることを意味します．一般にコレクタの挙動の予測は難しく，メモリが期待通りに解放されなかった理由を理解するのはとても難しいです．
- 「制御第一」の陣営は，プログラマにメモリ解放の責任を委ねます．プログラムのメモリ消費を自分で制御できますが，ダングリング・ポインタを回避するのもプログラマ次第となります．主要な言語でこの流れを汲むのは C/C++ だけです．もし，プログラマがミスをしないのであれば素晴らしいのですが，いずれミスは犯すものです．ポインタの誤用は，知っている限り報告されたセキュリティ問題の一般的な原因となっています．

Rust は安全性と性能の両立を目指しているので，どちらの妥協も許されません．
しかし，もし和解が簡単なら今よりずっと前に誰かがやっているはずです．
何か根本的なことを変える必要があります．

Rust はポインタの使い方を制限するという驚くべき方法でこのデッドロックを解消しています．
本章と次章では，この制限がどのようなもので，なぜ機能するのかを見ていきます．
今のところ，使い慣れた一般的な構造の中には，このルールに当てはまらないものもあり，その代わりを探す必要があるということを知っておくだけで十分です．
しかし，これらの制限の効果は，コンパイル時のチェックでダングリング・ポインタや二重解放，初期化していないメモリの使用など，メモリの安全性に関するエラーを起こさないように，混沌の中に一定の秩序をもたらすことにあります．
実行時には，C/C++ と同じように，ポインタはメモリ上の単なるアドレスになります．
違いはコードがポインタをお安全に使用できることが証明されていることです．

同じルールが安全な並列プログラミングのサポートの基礎にもなっています．
注意深く設計されたスレッディングのプリミティブを使うと，コードがメモリを正しく利用することを保証するルールがデータ競合を起こさない用にしてくれることがわかるでしょう．
Rustプログラムのバグによって，あるスレッドが他のスレッドのデータを破損し，システムの無関係な部分に再現困難な障害が発生することはありません．
マルチスレッドのコードに固有の非決定的な動作は，通常のメモリ参照には現れず，それを扱うように設計された機能 (ミューテックス，メッセージチャネル，アトミック値など) に分離されます．
C/C++ のマルチスレッドコードの評判は良くありませんが，Rust はこれを見事に修正しています．

Rust は，このような制約があっても，ほぼすべてのタスクに対して十分な柔軟性を持ち，メモリ管理や並行処理に関するさまざまなバグを排除することで，自分のスタイルに合わせる必要があることを正当化する，というのが，その成功に賭け，言語の根幹をなす主張なのです．
本書の著者が Rust を強く勧めるのは、まさに C/C++ の豊富な経験があり，Rust を扱うのに何の問題もないからです．

Rust のルールは，おそらく他のプログラミング言語では見たことがないものでしょう．
Rust の学習において，このルールがどのように機能するかを学び，使いこなすことが最も重要になってきます．
本章では，まず，Rustのルールの背後にある論理と意図について，他の言語と同じ根本的な問題がどのように発生するかを示します．
次に，Rustのルールを詳しく説明します．
概念的・機械的なレベルでの所有権の意味，さまざまなシナリオでの所有権の変更の追跡方法，より柔軟性を持たせるためにルールを曲げたり壊したりする型について見ていきます．

## 目次
- 4-1. [所有権](./1_Ownership.md)
- 4-2. [移動](./2_Moves.md)
- 4-3. [コピー型：移動の例外](./3_Copy_Types.md)
- 4-4. [Rc と Arc：所有権の共有](./4_Rc_and_Arc.md)